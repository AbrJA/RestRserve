% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RestRserveApplication.R
\docType{data}
\name{RestRserveApplication}
\alias{RestRserveApplication}
\title{Creates RestRserveApplication.}
\format{\code{\link{R6Class}} object.}
\usage{
RestRserveApplication
}
\description{
Creates RestRserveApplication object.
RestRserveApplication facilitates in turning user-supplied R code into high-performance REST API by
allowing to easily register R functions for handling http-requests.
}
\section{Usage}{

\itemize{
\item \code{app = RestRserveApplication$new()}
\item \code{app$add_route(path = "/echo", method = "GET", FUN =  function(request) {
  RestRserve::create_response(body = request$query[[1]], content_type = "text/plain")
  })}
\item \code{app$routes()}
}
For usage details see \bold{Methods, Arguments and Examples} sections.
}

\section{Methods}{

\describe{
  \item{\code{$new()}}{Constructor for RestRserveApplication. For the moment doesn't take any parameters.}
  \item{\code{$add_route(path, method, FUN, path_as_prefix = FALSE, ...)}}{ Adds endpoint
  and register user-supplied R function as a handler.
  User function \code{FUN} \bold{must} return object of the class \bold{"RestRserveResponse"}
  which can be easily constructed with \link{create_response}}
  \item{\code{$add_get(path, FUN, ...)}}{shorthand to \code{add_route} with \code{GET} method }
  \item{\code{$add_post(path, FUN, ...)}}{shorthand to \code{add_route} with \code{POST} method }
  \item{\code{$add_static(path, file_path, content_type = NULL, ...)}}{ adds GET method to serve
  file or directory at \code{file_path}. If \code{content_type = NULL}
  then MIME code \code{content_type}  will be inferred automatically (from file extension).
  If it will be impossible to guess about file type then \code{content_type} will be set to
  \code{"application/octet-stream"}}
  \item{\code{$run(port = "80", ...)}}{starts RestRserve application from current R session.
     \code{port} - http port for application.
     \code{...} - key-value pairs of the Rserve configuration.}
  \item{\code{$call_handler(request)}}{Used internally, \bold{usually users} don't need to call it.
  Calls handler function for a given request.}
  \item{\code{$routes()}}{Lists all registered routes}
  \item{\code{$print_endpoints_summary()}}{Prints all the registered routes with allowed methods}
  \item{\code{$add_openapi(path = "/openapi.yaml", openapi = openapi_create())}}{Adds endpoint
  to serve \href{https://www.openapis.org/}{OpenAPI} description of available methods.}
  \item{\code{$add_swagger_ui(path = "/swagger", path_openapi = "/openapi.yaml",
                              path_swagger_assets = "/__swagger__/",
                              file_path = tempfile(fileext = ".html"))}}{Adds endpoint to show swagger-ui.}
}
}

\section{Arguments}{

\describe{
 \item{app}{A \code{RestRserveApplication.} object}
 \item{path}{\code{character} of length 1. Should be valid path for example \code{'/a/b/c'}}
 \item{method}{\code{character} of length 1. At the moment one of \code{"GET", "POST", "HEAD"} }
 \item{FUN}{\code{function} which takes exactly one argument - \code{request}.
   \code{request} R object returned by \code{RestRserve:::parse_request()} function.
   Object corresponds to http-request and essentially \code{request} is a \code{list} with a fixed set of fields.
   Representation of the "GET" request to "http://localhost:8001/somemethod?a=1&b=2" will look like:
   \describe{
      \item{path}{ = \code{"/somepath"}, always character of length 1}
      \item{method}{ = \code{"GET"}, always character of length 1}
      \item{query}{ = \code{c("a" = "1", "b" = "2")}, named character vector. Queiry parameters key-value pairs.}
      \item{body}{ = \code{NULL}.
         \itemize{
            \item \code{NULL} if the http body is empty or zero length.
            \item \code{raw vector} with a "content-type" attribute in all cases except URL encoded form (if specified in the headers)
            \item named \code{characeter vector} in the case of a URL encoded form.
            It will have the same shape as the query string (named string vector).
         }
      }
      \item{content_type}{ = \code{""}, always character of length 1}
      \item{headers}{ = \code{c("a" = "1", "b" = "2")}, named character vector. key-value pairs from http-header.}
   }
 }
}
}

\examples{
echo_handler = function(request) {
 RestRserve::create_response(body = request$query[[1]],
                             content_type = "text/plain",
                            headers = "Location: /echo",
                            status_code = 201L)
}
app = RestRserveApplication$new()
app$add_route(path = "/echo", method = "GET", FUN = echo_handler)
req = list(query = c("a" = "2"), method = "GET", path = "/echo")
answer = app$call_handler(request = req)
answer$body
# "2"
}
\keyword{datasets}
